
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.LongFunction;
import java.util.function.LongSupplier;
import java.util.function.LongUnaryOperator;
import java.util.function.Predicate;

import processing.core.*;


import org.junit.Test;

public class PathingTest
{
   
   @Test
   public void testExercise1()
   {
      //List<Point> PATH = computePath(Point start, Point end, Predicate<Point> canPassThrough,
      //  BiPredicate<Point, Point> withinReach, Function<Point, Stream<Point>> potentialNeighbors);\
      // world = VirtualWorld.world;
      // Point start = new Point(1,2);
      // Point end = new Point(1,2);
       
      // Predicate<Point> canPassThrough = (p) -> !world.OccupyChecker( p);  //= new Predicate<Point>();\
      // BiPredicate<Point, Point> withinReach = (p, e) -> p.adjacent(e);  // sees if the two points are adjacent
       //Function<Point, Stream<Point>> potentialNeighbors
       
     // List<Point> PATH;
     //  PATH = SingleStepPathingStrategy.computePath(start, end, canPassThrough,
     //          withinReach, PathingStrategy.CARDINAL_NEIGHBORS);
      
   }
   
   @Test
   public void testExercise2()
   {
      
       
       
       
      
   }


}